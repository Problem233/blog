---
title: 这段时间的欧拉计划解题记录
date: 2017-07-13
tags:
  - 编程
  - Project Euler
  - Haskell
toc: true
---

刚好一个月过去了，这里列举一下这段时间的解题记录。

<!-- more -->

## Problem 13 Large sum

> 计算出以下一百个 50 位数的和的前十位数字。
>
> - 37107287533902102798797998220837590246510135740250
> - 46376937677490009712648124896970078050417018260538
> - 74324986199524741059474233309513058123726617309629
> - 91942213363574161572522430563301811072406154908250
> - 23067588207539346171171980310421047513778063246676
> - 89261670696623633820136378418383684178734361726757
> - 28112879812849979408065481931592621691275889832738
> - 44274228917432520321923589422876796487670272189318
> - 47451445736001306439091167216856844588711603153276
> - 70386486105843025439939619828917593665686757934951
> - 62176457141856560629502157223196586755079324193331
> - 64906352462741904929101432445813822663347944758178
> - 92575867718337217661963751590579239728245598838407
> - 58203565325359399008402633568948830189458628227828
> - 80181199384826282014278194139940567587151170094390
> - 35398664372827112653829987240784473053190104293586
> - 86515506006295864861532075273371959191420517255829
> - 71693888707715466499115593487603532921714970056938
> - 54370070576826684624621495650076471787294438377604
> - 53282654108756828443191190634694037855217779295145
> - 36123272525000296071075082563815656710885258350721
> - 45876576172410976447339110607218265236877223636045
> - 17423706905851860660448207621209813287860733969412
> - 81142660418086830619328460811191061556940512689692
> - 51934325451728388641918047049293215058642563049483
> - 62467221648435076201727918039944693004732956340691
> - 15732444386908125794514089057706229429197107928209
> - 55037687525678773091862540744969844508330393682126
> - 18336384825330154686196124348767681297534375946515
> - 80386287592878490201521685554828717201219257766954
> - 78182833757993103614740356856449095527097864797581
> - 16726320100436897842553539920931837441497806860984
> - 48403098129077791799088218795327364475675590848030
> - 87086987551392711854517078544161852424320693150332
> - 59959406895756536782107074926966537676326235447210
> - 69793950679652694742597709739166693763042633987085
> - 41052684708299085211399427365734116182760315001271
> - 65378607361501080857009149939512557028198746004375
> - 35829035317434717326932123578154982629742552737307
> - 94953759765105305946966067683156574377167401875275
> - 88902802571733229619176668713819931811048770190271
> - 25267680276078003013678680992525463401061632866526
> - 36270218540497705585629946580636237993140746255962
> - 24074486908231174977792365466257246923322810917141
> - 91430288197103288597806669760892938638285025333403
> - 34413065578016127815921815005561868836468420090470
> - 23053081172816430487623791969842487255036638784583
> - 11487696932154902810424020138335124462181441773470
> - 63783299490636259666498587618221225225512486764533
> - 67720186971698544312419572409913959008952310058822
> - 95548255300263520781532296796249481641953868218774
> - 76085327132285723110424803456124867697064507995236
> - 37774242535411291684276865538926205024910326572967
> - 23701913275725675285653248258265463092207058596522
> - 29798860272258331913126375147341994889534765745501
> - 18495701454879288984856827726077713721403798879715
> - 38298203783031473527721580348144513491373226651381
> - 34829543829199918180278916522431027392251122869539
> - 40957953066405232632538044100059654939159879593635
> - 29746152185502371307642255121183693803580388584903
> - 41698116222072977186158236678424689157993532961922
> - 62467957194401269043877107275048102390895523597457
> - 23189706772547915061505504953922979530901129967519
> - 86188088225875314529584099251203829009407770775672
> - 11306739708304724483816533873502340845647058077308
> - 82959174767140363198008187129011875491310547126581
> - 97623331044818386269515456334926366572897563400500
> - 42846280183517070527831839425882145521227251250327
> - 55121603546981200581762165212827652751691296897789
> - 32238195734329339946437501907836945765883352399886
> - 75506164965184775180738168837861091527357929701337
> - 62177842752192623401942399639168044983993173312731
> - 32924185707147349566916674687634660915035914677504
> - 99518671430235219628894890102423325116913619626622
> - 73267460800591547471830798392868535206946944540724
> - 76841822524674417161514036427982273348055556214818
> - 97142617910342598647204516893989422179826088076852
> - 87783646182799346313767754307809363333018982642090
> - 10848802521674670883215120185883543223812876952786
> - 71329612474782464538636993009049310363619763878039
> - 62184073572399794223406235393808339651327408011116
> - 66627891981488087797941876876144230030984490851411
> - 60661826293682836764744779239180335110989069790714
> - 85786944089552990653640447425576083659976645795096
> - 66024396409905389607120198219976047599490197230297
> - 64913982680032973156037120041377903785566085089252
> - 16730939319872750275468906903707539413042652315011
> - 94809377245048795150954100921645863754710598436791
> - 78639167021187492431995700641917969777599028300699
> - 15368713711936614952811305876380278410754449733078
> - 40789923115535562561142322423255033685442488917353
> - 44889911501440648020369068063960672322193204149535
> - 41503128880339536053299340368006977710650566631954
> - 81234880673210146739058568557934581403627822703280
> - 82616570773948327592232845941706525094512325230608
> - 22918802058777319719839450180888072429661980811197
> - 77158542502016545090413245809786882778948721859617
> - 72107838435069186155435662884062257473692284509516
> - 20849603980134001723930671666823555245252804609722
> - 53503534226472524250874054075591789781264330331690

### 思路

由于 Haskell 自带高精度，于是这题就成了水题，不解释。

### 题解

这里直接从标准输入读取 100 个数字。

```haskell
main :: IO ()
main = do
  str <- getContents
  let s = sum $ map read $ lines str :: Integer
  putStrLn $ take 10 $ show s
```

## Problem 14 Longest Collatz sequence

> 在正整数集上定义如下的迭代序列：
>
> $$n \rightarrow n / 2 (若 n 为偶数) \\\\
> n \rightarrow 3n + 1 (若 n 为奇数)$$
>
> 从 13 开始应用上述规则，我们可以生成如下的序列：
>
> $$13 \rightarrow 40 \rightarrow 20 \rightarrow 10 \rightarrow 5 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1$$
>
> 可以看出这个序列（从 13 开始到 1 结束）共有 10 项。尽管还没有被证明，但我们普遍认为，从任何数开始最终都能迭代至 1（“考拉兹猜想”）。
>
> 从小于一百万的哪个数开始，能够生成最长的序列呢？
>
> **注**：序列开始生成后其中的项可能超过一百万。

### 思路

用简单的记忆化优化暴力求解。

### 题解

需要加入 [array](http://hackage.haskell.org/package/array-0.5.2.0) 依赖。

```haskell
import Data.Ord (comparing)
import Data.Array (listArray, (!), assocs)

main :: IO ()
main = print $ fst $ maximumBy (comparing snd) $ assocs collatzArr
  where collatzArr = listArray (1, lenBound) $ 0 : map collatzLen [2..lenBound]
        collatzLen x
          | y <= lenBound = 1 + collatzArr ! y
          | otherwise = 1 + collatzLen y
          where y | even x = x `div` 2
                  | otherwise = x * 3 + 1
        lenBound = 1000000
```

## Problem 55 Lychrel numbers

> 将 47 倒序并相加得到 $47 + 74 = 121$，是一个回文数。
>
> 不是所有的数都能像这样迅速地变成回文数。例如，
>
> $$349 + 943 = 1292\\\\
> 1292 + 2921 = 4213\\\\
> 4213 + 3124 = 7337$$
>
> 也就是说，349 需要迭代三次才能变成回文数。
>
> 尽管尚未被证实，但有些数，例如 196，被认为永远不可能变成回文数。如果一个数永远不可能通过倒序并相加变成回文数，就被称为利克瑞尔数。出于理论的限制和问题的要求，在未被证否之前，我们姑且就认为这些数确实是利克瑞尔数。除此之外，已知对于任意一个小于一万的数，它要么在迭代 50 次以内变成回文数，要么就是没有人能够利用现今所有的计算能力将其迭代变成回文数。事实上，10677 是第一个需要超过50次迭代变成回文数的数，这个回文数是
> 4668731596684224866951378664（53 次迭代，28 位数）。
>
> 令人惊讶的是，有些回文数本身也是利克瑞尔数数；第一个例子是 4994。
>
> 小于一万的数中有多少利克瑞尔数？
>
> **注**：2007 年 4 月 24 日，题目略作修改，以强调目前利克瑞尔数理论的限制。

### 思路

暴力求解。

### 题解

``` haskell
main :: IO ()
main = print $ count isLychrel [1..10000]
  where isLychrel = loop 0
            where loop t x
                    | t == 0 = f
                    | t == 50 = True
                    | isPalindromic x  = False
                    | otherwise = f
                    where f = loop (t + 1) (x + read (reverse $ show x))
        isPalindromic n = let s = show n in s == reverse s
        count c = length . filter c
```

## Problem 56 Powerful Digit Sum

> 一 googol（$10 ^ {100}$）是一个巨大的数字：一后面跟着一百个零。$100 ^ {100}$ 则更是无法想像地巨大：一后面跟着两百个零。然而，尽管这两个数如此巨大，各位数字和却都只有 1。

> 若 $a, b \lt 100$，所有能表示为 $ab$ 的自然数中，最大的各位数字和是多少？

### 思路

暴力求解。

### 题解

``` haskell
import Data.Char (digitToInt)
import Data.List (sortBy)

main :: IO ()
main = print $ maximum [sum $ map (toInteger . digitToInt) $ show (a ^ b)
                       | a <- [1..99], b <- [1..99]]
```

## Problem 76 Counting summations

> 将 5 写成整数的和有 6 种不同的方式：
>
> - $4 + 1$
> - $3 + 2$
> - $3 + 1 + 1$
> - $2 + 2 + 1$
> - $2 + 1 + 1 + 1$
> - $1 + 1 + 1 + 1 + 1$
>
> 将 100 写成整数的和有多少种不同的方式？

### 思路

我一开始想用动规的思路，但后来发现在 Haskell 里很难实现。最后参考了 [这里的递归法](http://www.cnblogs.com/hoodlum1980/archive/2008/10/11/1308493.html)，用记忆化进行优化。

### 题解

需要加入 [array](http://hackage.haskell.org/package/array-0.5.2.0) 依赖。

``` haskell
import Data.Array (listArray, (!))

main :: IO ()
main = pack (n - 1) n
  where n = 100
        mem = listArray (1, n - 1)
              [listArray (1, n) [pack i v | v <- [1..n]]
              | i <- [1..(n - 1)]]
        pack i v
          | i == 1 || v == 1 = 1
          | i > v = mem ! v ! v
          | i == v = mem ! (i - 1) ! v + 1
          | otherwise = mem ! (i - 1) ! v + mem ! i ! (v - i)
```

## 测试环境

- 操作系统：Windows 10 Pro Insder Preview Build 16237
- Haskell 编译环境：GHC 8.0.2
- 依赖库版本：
  - array 0.5.2.0
