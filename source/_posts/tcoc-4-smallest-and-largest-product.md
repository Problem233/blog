---
title: TCOC004 最小乘积与最大乘积
date: 2017-04-15
tags:
  - 开发
  - the Collision of Code
toc: true
---

本期 TCOC 继续做欧拉计划的题目。这次的题目是 [欧拉计划 Problem 5 Smallest multiple](https://projecteuler.net/problem=5) 和 [欧拉计划 Problem 11 Largest product in a grid](https://projecteuler.net/problem=11)。这一期的说明会比较详细。

<!-- more -->

## 欧拉计划 Problem 5 Smallest multiple

> 2520 是能被 1 到 10 之间的每个整数整除的最小整数。那么能被 1 到 20 之间的每个整数整除的最小整数是几？

这道题应该是有两种解法，这里 C++ 和 Scala 用第一种暴力解法，Haskell 用分解质因数法。

### C++

```cpp
#include <iostream>

using namespace std;

bool check(int x) {
  for(int i = 2; i <= 20; i ++)
    if(x % i) return false;
  return true;
}

int main() {
  int r = 20;
  while(!check(r)) r += 20;
  cout << r << endl;
  return 0;
}
```

这就是暴力算法，不需要解释了吧……

### Scala

```scala
object Main extends App {
  def check(x: Int): Boolean = {
    for (i <- 2 to 20) if (x % i != 0) return false
    return true
  }
  var r = 20
  while (!check(r)) r += 20
  println(r)
}
```

继续暴力算法……然而在 Scala 里暴力算法明显慢了很多。

### Haskell

```haskell
main :: IO ()
main = print $ product $ map (\x ->
         last $ takeWhile (<= 20) $ map (x ^) [1..]) $
       takeWhile (<= 20) primes
  where primes = filterPrimes [2..]
        filterPrimes (x : xs) = x : filterPrimes
          (filter ((/= 0) . (`rem` x)) xs)
```

是的，就是这么短。那个`primes`就不解释了，这个算法大概是这样的：1 到 20 之间的整数，要么是 1，要么是质数，要么就是质数的幂（的乘积）。所以这里先找出 20 以内的所有质数，然后算出每个质数 20 以内的最大幂，相乘，就得到答案了。

## 欧拉计划 Problem 11 Largest product in a grid

> 在下面这个 $20 \times 20$ 网格内，同一直线上相邻的 4 个数字已经用粗体做了记号：
>
> > 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>
> > 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>
> > 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>
> > 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>
> > 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>
> > 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>
> > 32 98 81 28 64 23 67 10 **26** 38 40 67 59 54 70 66 18 38 64 70<br>
> > 67 26 20 68 02 62 12 20 95 **63** 94 39 63 08 40 91 66 49 94 21<br>
> > 24 55 58 05 66 73 99 26 97 17 **78** 78 96 83 14 88 34 89 63 72<br>
> > 21 36 23 09 75 00 76 44 20 45 35 **14** 00 61 33 97 34 31 33 95<br>
> > 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>
> > 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>
> > 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>
> > 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>
> > 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>
> > 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>
> > 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>
> > 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>
> > 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>
> > 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48<br>
>
> 它们的乘积是 $26 \times 63 \times 78 \times 14 = 1788696$。
>
> 在这个 $20 \times 20$ 网格内，同一直线上相邻 4 个数字的乘积的最大值是几？

这道题使用命令式明显比函数式方便很多。

### C++

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
  const int grid[][20] = {
    {8, 2, 22,97,38,15, 0,40, 0,75, 4, 5, 7,78,52,12,50,77,91, 8},
    {49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48, 4,56,62, 0},
    {81,49,31,73,55,79,14,29,93,71,40,67,53,88,30, 3,49,13,36,65},
    {52,70,95,23, 4,60,11,42,69,24,68,56, 1,32,56,71,37, 2,36,91},
    {22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80},
    {24,47,32,60,99, 3,45, 2,44,75,33,53,78,36,84,20,35,17,12,50},
    {32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70},
    {67,26,20,68, 2,62,12,20,95,63,94,39,63, 8,40,91,66,49,94,21},
    {24,55,58, 5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72},
    {21,36,23, 9,75, 0,76,44,20,45,35,14, 0,61,33,97,34,31,33,95},
    {78,17,53,28,22,75,31,67,15,94, 3,80, 4,62,16,14, 9,53,56,92},
    {16,39, 5,42,96,35,31,47,55,58,88,24, 0,17,54,24,36,29,85,57},
    {86,56, 0,48,35,71,89, 7, 5,44,44,37,44,60,21,58,51,54,17,58},
    {19,80,81,68, 5,94,47,69,28,73,92,13,86,52,17,77, 4,89,55,40},
    {4, 52, 8,83,97,35,99,16, 7,97,57,32,16,26,26,79,33,27,98,66},
    {88,36,68,87,57,62,20,72, 3,46,33,67,46,55,12,32,63,93,53,69},
    {4, 42,16,73,38,25,39,11,24,94,72,18, 8,46,29,32,40,62,76,36},
    {20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74, 4,36,16},
    {20,73,35,29,78,31,90, 1,74,31,49,71,48,86,81,16,23,57, 5,54},
    {1, 70,54,71,83,51,54,69,16,92,33,48,61,43,52, 1,89,19,67,48}
  };
  int maxp = 0;
  // 行
  for(int i = 0; i < 20; i ++) {
    const int* graw = grid[i];
    for(int j = 0; j < 20 - 4; j ++)
      maxp = max(maxp, graw[j] * graw[j + 1] * graw[j + 2] * graw[j + 3]);
  }
  // 列
  for(int j = 0; j < 20; j ++)
    for(int i = 0; i < 20 - 4; i ++)
      maxp = max(maxp, grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]);
  // 右斜
  for(int i = 0; i < 20 - 4; i ++)
    for(int j = 0; j < 20 - 4; j ++)
      maxp = max(maxp, grid[i][j] * grid[i + 1][j + 1] * grid[i + 2][j + 2] * grid[i + 3][j + 3]);
  // 左斜
  for(int i = 0; i < 20 - 4; i ++)
    for(int j = 3; j < 20; j ++)
      maxp = max(maxp, grid[i][j] * grid[i + 1][j - 1] * grid[i + 2][j - 2] * grid[i + 3][j - 3]);
  cout << maxp << endl;
  return 0;
}
```

简直不能更加简单粗暴。

### Scala

Scala 里大概也是一样的解法。

```scala
import math.max

object Main extends App {
  val grid = Array(
    Array(8, 2, 22,97,38,15, 0,40, 0,75, 4, 5, 7,78,52,12,50,77,91, 8),
    Array(49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48, 4,56,62, 0),
    Array(81,49,31,73,55,79,14,29,93,71,40,67,53,88,30, 3,49,13,36,65),
    Array(52,70,95,23, 4,60,11,42,69,24,68,56, 1,32,56,71,37, 2,36,91),
    Array(22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80),
    Array(24,47,32,60,99, 3,45, 2,44,75,33,53,78,36,84,20,35,17,12,50),
    Array(32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70),
    Array(67,26,20,68, 2,62,12,20,95,63,94,39,63, 8,40,91,66,49,94,21),
    Array(24,55,58, 5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72),
    Array(21,36,23, 9,75, 0,76,44,20,45,35,14, 0,61,33,97,34,31,33,95),
    Array(78,17,53,28,22,75,31,67,15,94, 3,80, 4,62,16,14, 9,53,56,92),
    Array(16,39, 5,42,96,35,31,47,55,58,88,24, 0,17,54,24,36,29,85,57),
    Array(86,56, 0,48,35,71,89, 7, 5,44,44,37,44,60,21,58,51,54,17,58),
    Array(19,80,81,68, 5,94,47,69,28,73,92,13,86,52,17,77, 4,89,55,40),
    Array(4, 52, 8,83,97,35,99,16, 7,97,57,32,16,26,26,79,33,27,98,66),
    Array(88,36,68,87,57,62,20,72, 3,46,33,67,46,55,12,32,63,93,53,69),
    Array(4, 42,16,73,38,25,39,11,24,94,72,18, 8,46,29,32,40,62,76,36),
    Array(20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74, 4,36,16),
    Array(20,73,35,29,78,31,90, 1,74,31,49,71,48,86,81,16,23,57, 5,54),
    Array(1, 70,54,71,83,51,54,69,16,92,33,48,61,43,52, 1,89,19,67,48)
  )
  var maxp = 0
  // 横行可以用更美观的方法
  for (
    l <- grid;
    p <- l.tails.withFilter(_.length >= 4).map(_.take(4).product)
  ) maxp = max(maxp, p)
  for (
    j <- 0 until 20;
    i <- 0 until (20 - 4)
  ) maxp = max(maxp, grid(i)(j) * grid(i + 1)(j) * grid(i + 2)(j) * grid(i + 3)(j))
  for (
    i <- 0 until (20 - 4);
    j <- 0 until (20 - 4)
  ) maxp = max(maxp, grid(i)(j) * grid(i + 1)(j + 1) * grid(i + 2)(j + 2) * grid(i + 3)(j + 3))
  for (
    i <- 0 until (20 - 4);
    j <- 3 until 20
  ) maxp = max(maxp, grid(i)(j) * grid(i + 1)(j - 1) * grid(i + 2)(j - 2) * grid(i + 3)(j - 3))
  println(maxp)
}
```

### Haskell

由于 Haskell 里要使用数组还需要引入一个依赖，所以这里使用了链表，通过旋转来解题。

```haskell
import Data.List (transpose, tails)

main :: IO ()
main = print $ maximum [vmax, hmax, lsmax, rsmax]
  where vmax = rowsMaxProduct grid
        hmax = rowsMaxProduct $ transpose grid
        lsmax = rowsMaxProduct $ rotate grid
        rsmax = rowsMaxProduct $ rotate $ reverse grid
        rowsMaxProduct = maximum .
                         concatMap (
                           map (product . take 4) .
                           filter ((>= 4) . length) . tails)
        rotate (fl : rl) = rotateRec rl [fl]
          where rotateRec _ [] = []
                rotateRec l r  = map head r : case l of
                  [] -> rotateRec [] (removeNull $ map tail r)
                  (lh : lt) ->
                    rotateRec lt (lh : removeNull (map tail r))
                  where removeNull = filter (not . null)
        grid =
          [
            [8, 2, 22,97,38,15, 0,40, 0,75, 4, 5, 7,78,52,12,50,77,91, 8],
            [49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48, 4,56,62, 0],
            [81,49,31,73,55,79,14,29,93,71,40,67,53,88,30, 3,49,13,36,65],
            [52,70,95,23, 4,60,11,42,69,24,68,56, 1,32,56,71,37, 2,36,91],
            [22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80],
            [24,47,32,60,99, 3,45, 2,44,75,33,53,78,36,84,20,35,17,12,50],
            [32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70],
            [67,26,20,68, 2,62,12,20,95,63,94,39,63, 8,40,91,66,49,94,21],
            [24,55,58, 5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72],
            [21,36,23, 9,75, 0,76,44,20,45,35,14, 0,61,33,97,34,31,33,95],
            [78,17,53,28,22,75,31,67,15,94, 3,80, 4,62,16,14, 9,53,56,92],
            [16,39, 5,42,96,35,31,47,55,58,88,24, 0,17,54,24,36,29,85,57],
            [86,56, 0,48,35,71,89, 7, 5,44,44,37,44,60,21,58,51,54,17,58],
            [19,80,81,68, 5,94,47,69,28,73,92,13,86,52,17,77, 4,89,55,40],
            [4, 52, 8,83,97,35,99,16, 7,97,57,32,16,26,26,79,33,27,98,66],
            [88,36,68,87,57,62,20,72, 3,46,33,67,46,55,12,32,63,93,53,69],
            [4, 42,16,73,38,25,39,11,24,94,72,18, 8,46,29,32,40,62,76,36],
            [20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74, 4,36,16],
            [20,73,35,29,78,31,90, 1,74,31,49,71,48,86,81,16,23,57, 5,54],
            [1, 70,54,71,83,51,54,69,16,92,33,48,61,43,52, 1,89,19,67,48]
          ]
```

这里的`transpose`是矩阵转置，而`rotate`是把网格顺时针旋转 45°，算法简单地说就是从网格左上角开始按斜行取数，再放到新的链表中。

## 总结

这一期 TCOC 很好的展现了命令式与函数式之间的区别。[Problem 5](#欧拉计划-Problem-5-Smallest-multiple) 里 Haskell 的算法完爆 C++ 和 Scala，而 [Problem 11](#欧拉计划-Problem-11-Largest-product-in-a-grid) 用 Haskell 来解决则比另两个语言复杂得多。

## 测试环境

- 操作系统：x86_64 Linux 4.10.8-1-ARCH
- C++ 编译环境：GCC 6.3.1
- Scala 编译环境：Scala 2.12.1
- Haskell 编译环境：GHC 8.0.2

## 下期预告

下一期的题目是 [洛谷](https://www.luogu.org/) 上的 [「数列分段」](https://www.luogu.org/problem/show?pid=1181) 和 [「混合牛奶」](https://www.luogu.org/problem/show?pid=1208)。感兴趣的读者可以写别的语言的版本然后在 Github 上的 [Issues 页面](https://github.com/Problem233/blog/issues) 提交你的答案~
